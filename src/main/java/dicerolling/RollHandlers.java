package dicerolling;

import doom.DoomHandler;
import listeners.RollComponentInteractionListener;
import org.javacord.api.entity.message.MessageBuilder;
import org.javacord.api.entity.message.MessageFlag;
import org.javacord.api.entity.message.embed.EmbedBuilder;
import org.javacord.api.entity.user.User;
import org.javacord.api.event.message.MessageCreateEvent;
import org.javacord.api.interaction.SlashCommandInteraction;
import org.javacord.api.interaction.callback.InteractionOriginalResponseUpdater;
import sheets.PlotPointUtils;
import util.ComponentUtils;
import util.RandomColor;
import util.UtilFunctions;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class RollHandlers {
    //TODO Add doom point integration

    /**
     * Creates a completable future of the embeds that have to be sent
     *
     * @param username   The name of the user in the channel the embeds will be sent in
     * @param user       The user, used for getting the user's icon
     * @param rollResult The result of the roll
     * @return A completable future with the embeds generated by the roll
     */
    public static CompletableFuture<EmbedBuilder[]> getRollEmbeds(String username, User user, RollResult rollResult) {
        CompletableFuture<List<EmbedBuilder>> rollResultEmbeds = CompletableFuture.completedFuture(new ArrayList<>());
        rollResultEmbeds = UtilFunctions.appendElementToCompletableFutureList(rollResultEmbeds, rollResult.getResultEmbed().setAuthor(username, "", user.getAvatar()).setColor(RandomColor.getRandomColor()));

        // Add plot point expenditure embeds
        final int plotPointsSpent = rollResult.getPlotPointsSpent();
        if (plotPointsSpent != 0) {
            final Optional<Integer> plotPointModifyFuture = PlotPointUtils.addPlotPointsToUser(user, plotPointsSpent * -1).join();
            final Optional<EmbedBuilder> plotPointSpentEmbed = plotPointModifyFuture.map(integer -> new EmbedBuilder()
                    .setTitle("Using " + plotPointsSpent + " plot points!")
                    .setColor(RandomColor.getRandomColor())
                    .addField(username, (integer + plotPointsSpent) + " → " + integer));
            if (plotPointSpentEmbed.isPresent()) {
                rollResultEmbeds = UtilFunctions.appendElementToCompletableFutureList(rollResultEmbeds, plotPointSpentEmbed.get());
            }
        }
        // Add doom embeds
        final int doomGenerated = rollResult.getDoomGenerated();
        if (doomGenerated > 0) {
            DoomHandler.addDoom(doomGenerated);
            final CompletableFuture<Optional<EmbedBuilder>> opportunityFuture = PlotPointUtils.addPlotPointsToUser(user, 1)
                    .thenApply(newPlotPoints -> newPlotPoints.map(integer -> new EmbedBuilder()
                            .setTitle("An opportunity!")
                            .setColor(Color.DARK_GRAY)
                            .addField(username, (integer - 1) + " → " + integer)
                            .addField(DoomHandler.getActivePool(), (DoomHandler.getDoom() - doomGenerated) + " → " + DoomHandler.getDoom())));
            rollResultEmbeds = UtilFunctions.appendOptionalToCompletableFutureList(rollResultEmbeds, opportunityFuture);
        }

        return rollResultEmbeds.thenApply(embedBuilders -> embedBuilders.toArray(new EmbedBuilder[0]));
    }

    /**
     * Handles a roll made through a slash command
     *
     * @param event       The event that contains the user, channel, and responder objects
     * @param dicePool    The dicepool the user is rolling
     * @param discount    The plot point discount on the roll
     * @param diceKept    The number of dice kept
     * @param enhanceable If there is an enhancement override on the roll
     * @param opportunity If opportunities are enabled
     */
    public static void handleSlashCommandRoll(SlashCommandInteraction event, String dicePool, Integer discount, Integer diceKept, @SuppressWarnings("OptionalUsedAsFieldOrParameterType") Optional<Boolean> enhanceable, Boolean opportunity) {
        final User user = event.getUser();
        final Optional<RollResult> resultOptional = new DicePoolBuilder(user, dicePool).withDiceKept(diceKept).withDiscount(discount).withEnhanceable(enhanceable).withOpportunity(opportunity).getResults();
        if (resultOptional.isPresent()) {
            final CompletableFuture<InteractionOriginalResponseUpdater> respondLater = event.respondLater();
            final RollResult rollInfo = resultOptional.get();
            final CompletableFuture<EmbedBuilder[]> rollEmbeds = getRollEmbeds(event.getChannel()
                    .map(channel -> UtilFunctions.getUsernameInChannel(user, channel))
                    .orElseGet(user::getName), user, rollInfo);
            // TODO Handle removal of footer
            respondLater.thenAcceptBoth(rollEmbeds, (updater, embedBuilders) -> updater
                    .addEmbeds(embedBuilders)
                    .addComponents(ComponentUtils.createRollComponentRows(true, rollInfo.isEnhanceable()))
                    .update()
                    .thenAccept(message -> message.getChannel().addMessageComponentCreateListener(new RollComponentInteractionListener(rollInfo, message.getId())).removeAfter(60, TimeUnit.SECONDS).addRemoveHandler(() -> updater.removeAllComponents().update())));
        }
        else {
            event.createImmediateResponder().setContent("Invalid dice pool!").setFlags(MessageFlag.EPHEMERAL).respond();
        }
    }

    /**
     * Handles a roll made through a text command
     *
     * @param event   The event that contains the channel the message was sent from
     * @param user    The user that made the roll
     * @param builder The dice pool to roll with
     */
    public static void handleTextCommandRoll(MessageCreateEvent event, User user, DicePoolBuilder builder) {
        if (builder.getResults().isPresent()) {
            RollResult rollResult = builder.getResults().get();
            final CompletableFuture<EmbedBuilder[]> rollEmbeds = getRollEmbeds(UtilFunctions.getUsernameInChannel(user, event.getChannel()), user, rollResult);
            rollEmbeds.thenAccept(embeds -> new MessageBuilder()
                    .addEmbeds(embeds)
                    .addComponents(ComponentUtils.createRollComponentRows(true, rollResult.isEnhanceable())).send(event.getChannel()).thenAccept(message -> message.getChannel().addMessageComponentCreateListener(new RollComponentInteractionListener(rollResult, message.getId())).removeAfter(60, TimeUnit.SECONDS)));
        }
        else {
            event.getChannel().sendMessage("Invalid dice pool!");
        }
    }

}
